type: edu
custom_name: Can I have the Menu?
files:
- name: src/tictactoe/ApplicationRunner.java
  visible: true
  text: |
    package tictactoe;

    public class ApplicationRunner {
        public static void main(String[] args) {
            new TicTacToe();
        }
    }
  learner_created: false
- name: src/tictactoe/TicTacToe.java
  visible: true
  text: |-
    package tictactoe;

    import javax.swing.*;

    public class TicTacToe extends JFrame {
        public TicTacToe() {
            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            setSize(300, 300);
            setVisible(true);
            setLayout(null);
        }
    }
  learner_created: false
- name: test/TicTacToeTest.java
  visible: false
  text: |
    import org.assertj.swing.fixture.JButtonFixture;
    import org.assertj.swing.fixture.JLabelFixture;
    import org.assertj.swing.fixture.JMenuItemFixture;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.SwingTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.swing.SwingComponent;
    import tictactoe.TicTacToe;

    import javax.swing.JButton;
    import java.text.MessageFormat;
    import java.text.StringCharacterIterator;
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.List;
    import java.util.Map;
    import java.util.stream.Stream;

    import static java.util.stream.IntStream.range;
    import static org.hyperskill.hstest.testcase.CheckResult.correct;

    public class TicTacToeTest extends SwingTest {
        private static final String EMPTY_CELL = " ";
        private static final String MARK_X = "X";
        private static final String MARK_O = "O";
        private static final Map<String, String> GAME_STATE = Map.of(
                "--", "Game is not started",
                "H1", "The turn of Human Player (X)",
                "R1", "The turn of Robot Player (X)",
                "H2", "The turn of Human Player (O)",
                "R2", "The turn of Robot Player (O)",
                "HX", "The Human Player (X) wins",
                "RX", "The Robot Player (X) wins",
                "HO", "The Human Player (O) wins",
                "RO", "The Robot Player (O) wins",
                "DW", "Draw");

        public TicTacToeTest() {
            super(new TicTacToe());
        }

        @SwingComponent
        private JButtonFixture buttonA1;
        @SwingComponent
        private JButtonFixture buttonA2;
        @SwingComponent
        private JButtonFixture buttonA3;
        @SwingComponent
        private JButtonFixture buttonB1;
        @SwingComponent
        private JButtonFixture buttonB2;
        @SwingComponent
        private JButtonFixture buttonB3;
        @SwingComponent
        private JButtonFixture buttonC1;
        @SwingComponent
        private JButtonFixture buttonC2;
        @SwingComponent
        private JButtonFixture buttonC3;
        @SwingComponent
        private JButtonFixture buttonStartReset;
        @SwingComponent
        private JButtonFixture buttonPlayer1;
        @SwingComponent
        private JButtonFixture buttonPlayer2;
        @SwingComponent
        private JLabelFixture labelStatus;
        @SwingComponent
        private JMenuItemFixture menuGame;
        @SwingComponent
        private JMenuItemFixture menuHumanHuman;
        @SwingComponent
        private JMenuItemFixture menuHumanRobot;
        @SwingComponent
        private JMenuItemFixture menuRobotHuman;
        @SwingComponent
        private JMenuItemFixture menuRobotRobot;
        @SwingComponent
        private JMenuItemFixture menuExit;

        private Stream<JButtonFixture> cells() {
            return Stream.of(
                    buttonA3, buttonB3, buttonC3,
                    buttonA2, buttonB2, buttonC2,
                    buttonA1, buttonB1, buttonC1
            );
        }

        private Map<String, JButtonFixture> board;

        private final List<JButton> buttons = new ArrayList<>();

        @DynamicTest(feedback = "Cells should be visible")
        CheckResult test1() {
            cells().forEach(this::requireVisible);
            cells().map(JButtonFixture::target).forEach(buttons::add);
            board = Map.of(
                    "A3", buttonA3, "B3", buttonB3, "C3", buttonC3,
                    "A2", buttonA2, "B2", buttonB2, "C2", buttonC2,
                    "A1", buttonA1, "B1", buttonB1, "C1", buttonC1,
                    "SR", buttonStartReset);
            return correct();
        }

        @DynamicTest(feedback = "Cells should be disabled before the start of the game")
        CheckResult test2() {
            cells().forEach(this::requireDisabled);
            return correct();
        }

        @DynamicTest(feedback = "All cells should be empty before the game")
        CheckResult test3() {
            cells().forEach(cell -> cell.requireText(EMPTY_CELL));
            return correct();
        }

        private int[] cols;
        private int[] rows;

        @DynamicTest(feedback = "The board should have exactly three rows and columns")
        CheckResult test4() {
            cols = buttons.stream().mapToInt(JButton::getX).distinct().sorted().toArray();
            rows = buttons.stream().mapToInt(JButton::getY).distinct().sorted().toArray();

            assertEquals(3, cols.length,
                    "The board should have exactly 3 columns. "
                            + "The column coordinates are {0}, "
                            + "the buttons have {1} different column coordinates",
                    Arrays.toString(cols), cols.length);

            assertEquals(3, rows.length,
                    "The board should have exactly 3 rows. "
                            + "The row coordinates are {0}, "
                            + "The buttons have {0} different row coordinates",
                    Arrays.toString(rows), rows.length);

            return correct();
        }

        private static final String[] ROW_NAME = new String[]{"top", "middle", "bottom"};
        private static final String[] COL_NAME = new String[]{"left", "middle", "right"};

        @DynamicTest(feedback = "The buttons are incorrectly placed on the board")
        CheckResult test5() {
            range(0, 9).forEach(index -> {

                assertEquals(rows[index / 3], buttons.get(index).getY(),
                        "The button {0} should be located in the {1} row",
                        buttons.get(index).getText(), ROW_NAME[index / 3]);

                assertEquals(cols[index % 3], buttons.get(index).getX(),
                        "The button {0} should be located in the {1} column",
                        buttons.get(index).getText(), COL_NAME[index % 3]);
            });

            return correct();
        }

        @DynamicTest(feedback = "Add a JLabel with the name of 'LabelStatus' as status bar")
        CheckResult test6() {
            labelStatus.requireVisible();
            return correct();
        }

        @DynamicTest(feedback = "The status bar should contain the following text: 'Game is not started' before the game")
        CheckResult test7() {
            labelStatus.requireText(GAME_STATE.get("--"));
            return correct();
        }

        @DynamicTest(feedback = "Add a JButton with the name of 'ButtonStartReset' and enable it")
        CheckResult test8() {
            buttonStartReset.requireEnabled();
            return correct();
        }

        @DynamicTest(feedback = "The 'ButtonStartReset' component should have the following text: 'Start' after the program starts")
        CheckResult test9() {
            buttonStartReset.requireText("Start");
            return correct();
        }

        @DynamicTest(feedback = "Once the game is started, change the 'Start' button to 'Reset'")
        CheckResult test10() {
            buttonStartReset.click();
            buttonStartReset.requireText("Reset");
            return correct();
        }

        @DynamicTest(feedback = "Cells should be enabled after the game is started")
        CheckResult test12() {
            cells().forEach(this::requireEnabled);
            return correct();
        }

        @DynamicTest(feedback = "Once the game is started, the status should indicate the first player turn")
        CheckResult test13() {
            labelStatus.requireText(GAME_STATE.get("H1"));
            return correct();
        }

        @DynamicTest(feedback = "Disable player buttons once the game has started." +
                " Expected text: 'The turn of Human Player (X)'")
        CheckResult test14() {
            buttonPlayer1.requireDisabled();
            buttonPlayer2.requireDisabled();
            return correct();
        }

        @DynamicTest(feedback = "Display 'X' after the first move" +
                " and the status should indicate the turn of the second player")
        CheckResult test15() {
            buttonA1.click();
            buttonA1.requireText(MARK_X);
            labelStatus.requireText(GAME_STATE.get("H2"));
            return correct();
        }

        @DynamicTest(feedback = "Display 'O' after the second move" +
                " and the status should indicate the turn of the first player")
        CheckResult test16() {
            buttonA3.click();
            buttonA3.requireText(MARK_O);
            labelStatus.requireText(GAME_STATE.get("H1"));
            return correct();
        }

        @DynamicTest(feedback = "The Reset button should finish the game " +
                "enable player buttons")
        CheckResult test17() {
            buttonStartReset.click();
            buttonPlayer1.requireEnabled();
            buttonPlayer2.requireEnabled();
            return correct();
        }

        @DynamicTest(feedback = "The Reset button should clear the board" +
                " and the status should indicate 'Game is not started'")
        CheckResult test19() {
            cells().forEach(cell -> cell.requireText(EMPTY_CELL));
            labelStatus.requireText(GAME_STATE.get("--"));
            return correct();
        }

        private final String[][] humanVsHuman = new String[][]{
                {"SR", "_________", "H1"},
                {"A1", "______X__", "H2"}, {"B1", "______XO_", "H1"},
                {"C3", "__X___XO_", "H2"}, {"B3", "_OX___XO_", "H1"},
                {"B2", "_OX_X_XO_", "HX"}, {"SR", "_________", "--"},

                {"SR", "_________", "H1"},
                {"B2", "____X____", "H2"}, {"A1", "____X_O__", "H1"},
                {"C1", "____X_O_X", "H2"}, {"A3", "O___X_O_X", "H1"},
                {"A2", "O__XX_O_X", "H2"}, {"C2", "O__XXOO_X", "H1"},
                {"B3", "OX_XXOO_X", "H2"}, {"B1", "OX_XXOOOX", "H1"},
                {"C3", "OXXXXOOOX", "DW"}, {"B2", "OXXXXOOOX", "DW"},
                {"B2", "OXXXXOOOX", "DW"}, {"SR", "_________", "--"},

                {"SR", "_________", "H1"},
                {"A2", "___X_____", "H2"}, {"B2", "___XO____", "H1"},
                {"A1", "___XO_X__", "H2"}, {"A3", "O__XO_X__", "H1"},
                {"C1", "O__XO_X_X", "H2"}, {"B1", "O__XO_XOX", "H1"},
                {"C2", "O__XOXXOX", "H2"}, {"B3", "OO_XOXXOX", "HO"},
                {"A3", "OO_XOXXOX", "HO"}, {"C3", "OO_XOXXOX", "HO"},
                {"C3", "OO_XOXXOX", "HO"}, {"B2", "OO_XOXXOX", "HO"},
                {"SR", "_________", "--"}, {"SR", "_________", "H1"},
                {"SR", "_________", "--"}, {"SR", "_________", "H1"},

                {"C1", "________X", "H2"}, {"B1", "_______OX", "H1"},
                {"B2", "____X__OX", "H2"}, {"C2", "____XO_OX", "H1"},
                {"A3", "X___XO_OX", "HX"}, {"B3", "X___XO_OX", "HX"},
                {"C3", "X___XO_OX", "HX"}, {"A1", "X___XO_OX", "HX"},
                {"A1", "X___XO_OX", "HX"}, {"SR", "_________", "--"},

                // Test for double click on the same cells
                {"SR", "_________", "H1"},
                {"B2", "____X____", "H2"}, {"B2", "____X____", "H2"},
                {"B2", "____X____", "H2"}, {"C1", "____X___O", "H1"},
                {"C1", "____X___O", "H1"}, {"C1", "____X___O", "H1"},
                {"SR", "_________", "--"},

        };

        @DynamicTest(data = "humanVsHuman", feedback = "Incorrect game state")
        CheckResult test20(final String cell, final String position, final String state) {
            board.get(cell).click();
            labelStatus.requireText(GAME_STATE.get(state));
            final var iter = new StringCharacterIterator(" " + position.replace('_', ' '));
            cells().forEach(c -> c.requireText(String.valueOf(iter.next())));
            return correct();
        }


        @DynamicTest(feedback = "The player buttons should be Human vs Human")
        CheckResult test30() {
            buttonPlayer1.requireText("Human");
            buttonPlayer2.requireText("Human");
            return correct();
        }

        @DynamicTest(feedback = "The player buttons should switch Human/Robot")
        CheckResult test40() {
            buttonPlayer1.click();
            buttonPlayer1.requireText("Robot");
            buttonPlayer1.click();
            buttonPlayer1.requireText("Human");

            buttonPlayer2.click();
            buttonPlayer2.requireText("Robot");
            buttonPlayer2.click();
            buttonPlayer2.requireText("Human");
            buttonPlayer2.click();
            buttonPlayer2.requireText("Robot");
            return correct();
        }

        @DynamicTest(feedback = "After selecting 'Human vs Human', the game should start. " +
                "Both buttons should be set to 'Human' and disabled. " +
                "The Start/Reset button should be set to 'Reset' and the cells should be enabled. " +
                "The status should indicate the first human player turn.")
        CheckResult test50() {
            menuHumanHuman.requireEnabled();
            menuHumanHuman.requireVisible();
            menuHumanHuman.click();
            buttonPlayer1.requireText("Human");
            buttonPlayer2.requireText("Human");
            buttonPlayer1.requireDisabled();
            buttonPlayer2.requireDisabled();
            buttonStartReset.requireText("Reset");
            cells().forEach(this::requireEnabled);
            labelStatus.requireText(GAME_STATE.get("H1"));
            return correct();
        }

        @DynamicTest(feedback = "After selecting 'Human vs Robot', the game should start. " +
                "The first player button should be set to 'Human' and disabled. " +
                "The second player button should be set to 'Robot' and disabled. " +
                "The Start/Reset button should be set to 'Reset' and the cells should be enabled. " +
                "The status should indicate the first human player turn.")
        CheckResult test60() {
            menuHumanRobot.requireEnabled();
            menuHumanRobot.requireVisible();
            menuHumanRobot.click();
            buttonPlayer1.requireText("Human");
            buttonPlayer2.requireText("Robot");
            buttonPlayer1.requireDisabled();
            buttonPlayer2.requireDisabled();
            buttonStartReset.requireText("Reset");
            cells().forEach(this::requireEnabled);
            labelStatus.requireText(GAME_STATE.get("H1"));
            return correct();
        }

        @DynamicTest(feedback = "After selecting 'Human vs Robot', the game should start. " +
                "The first player button should be set to 'Robot' and disabled. " +
                "The second player button should be set to 'Human' and disabled. " +
                "The Start/Reset button should be set to 'Reset' and the cells should be enabled.")
        CheckResult test70() {
            menuRobotHuman.requireEnabled();
            menuRobotHuman.requireVisible();
            menuRobotHuman.click();
            buttonPlayer1.requireText("Robot");
            buttonPlayer2.requireText("Human");
            buttonPlayer1.requireDisabled();
            buttonPlayer2.requireDisabled();
            buttonStartReset.requireText("Reset");
            cells().forEach(this::requireEnabled);
            return correct();
        }

        @DynamicTest(feedback = "After selecting 'Robot vs Robot', the game should start. " +
                "Both player's buttons should be set to 'Robot' and disabled. " +
                "The Start/Reset button should be set to 'Reset' and the cells should be enabled.")
        CheckResult test80() {
            menuRobotRobot.requireEnabled();
            menuRobotRobot.requireVisible();
            menuRobotRobot.click();
            buttonPlayer1.requireText("Robot");
            buttonPlayer2.requireText("Robot");
            buttonPlayer1.requireDisabled();
            buttonPlayer2.requireDisabled();
            buttonStartReset.requireText("Reset");
            return correct();
        }

        private static void assertEquals(
                final Object expected,
                final Object actual,
                final String error,
                final Object... args) {

            if (!expected.equals(actual)) {
                final var feedback = MessageFormat.format(error, args);
                throw new WrongAnswer(feedback);
            }
        }
    }
  learner_created: false
- name: src/tictactoe/GamePad.java
  visible: true
  text: |-
    package tictactoe;

    import javax.swing.*;
    import java.awt.*;
    import java.util.Random;

    class GamePad extends JPanel {
        private final int WIDTH;
        private final int HEIGHT;
        private final int ROWS; //The game pad is assumed to be square
        private final int COLS; //ROWS must equal COLS
        private final int TARGET;
        private final Font markerFont = new Font("Ariel Black", Font.BOLD, 26);
        private String move = new String("X");
        private JButton[][] buttons;
        public enum Status {NOT_STARTED, IN_PROGRESS, X_WINS, O_WINS, DRAW};
        private Status status;
        private GamePadStatusBar statusBar;
        private boolean[] autoPlay = new boolean[2]; //Enable auto for X index 0 or O index 1
        private Random random = new Random();


        public GamePad(int width, int height, int rows, int cols) {
            this.WIDTH = width;
            this.HEIGHT = height;
            this.ROWS = rows;
            this.COLS = cols;
            this.TARGET = cols;  //row = cols target full row col or diagonal


            setSize(width, height);

            buttons = new JButton[rows][cols];

            init();

            LayoutManager grlo = new GridLayout(rows, cols, 3, 3);
            setLayout(grlo);
            setVisible(true);
            reset();
        }

        public GamePad() {
            this.WIDTH = 300;
            this.HEIGHT = 300;
            this.ROWS = 3;
            this.COLS = 3;
            this.move = "X";
            this.TARGET = 3;
        }

        public void setStatusBar(GamePadStatusBar statusBar) {
            this.statusBar = statusBar;
            statusBar.refreshStatusLabel();
        }

        private void init() {
            move = "X";
            status = Status.NOT_STARTED;
            for (int row = 0; row < ROWS; row++) {
                for (int col = 0; col < COLS; col++) {
                    buttons[row][col] = new JButton();
                    buttons[row][col].setName("Button" + getLabel(row, col));
                    buttons[row][col].setFont(markerFont);
                    buttons[row][col].addActionListener(new ButtonActionListener(buttons[row][col], this));
                    add(buttons[row][col]);
                }
            }
            enableGameButtons(false);
        }

        public void reset() {
            move = "X";
            status = Status.NOT_STARTED;
            for (int row = 0; row < ROWS; row++) {
                for (int col = 0; col < COLS; col++) {
                    buttons[row][col].setText(" ");
                    buttons[row][col].setEnabled(false);
                }
            }
            if (statusBar != null) {
                statusBar.refreshStatusLabel();
            }
        }

        public void start() {
            this.status = Status.IN_PROGRESS;
            move = "X";
            statusBar.refreshStatusLabel();
            enableGameButtons(true);
            if (autoPlay[0] && autoPlay[1]) {
                //computer vs computer
                AutoPlayer ap = new AutoPlayer(this);
                ap.execute();
            } else {
                play();
            }
        }



        private  String getLabel(int row, int col) {
            int rowNumber = ROWS - row;
            char colChar = (char) (col + 'A');
            return new String(String.valueOf(colChar) + Integer.toString(rowNumber));
        }

        public String getMove() {
            return move;
        }

        public void setMove(String move) {
            this.move = move;
        }

        public void setAutoPlayX(boolean autoPlay) {
            this.autoPlay[0] = autoPlay;
        }

        public void setAutoPlayO(boolean autoPlay) {
            this.autoPlay[1] = autoPlay;
        }

        public void play() {
            if (isAutoMode()) {
                autoPlay();
            }
        }

        public boolean isAutoMode() {
            if (move.equals("X") && autoPlay[0]) {
                return true;
            } else if (move.equals("O") && autoPlay[1]) {
                return  true;
            } else {
                return  false;
            }
        }

        public int getROWS() {
            return ROWS;
        }

        public int getCOLS() {
            return COLS;
        }
        public boolean isRobot(String move) {
            if (move.equals("X") && autoPlay[0]) {
                return true;
            } else if (move.equals("O") && autoPlay[1]) {
                return true;
            } else if (move.equals("X") || move.equals("O")) {
                return false;
            } else {
                JOptionPane.showMessageDialog(this, "Warning, invalid move: " + move);
                return false;
            }

        }

        private int count(String s) {
            //count max number of string in rows cols or diagonals
            int c = 0;
            int d1 = 0;
            int d2 = 0;
            int d3 = 0;
            int d4 = 0;
            for (int row = 0; row < ROWS; row++) {
                for (int col = 0; col < COLS; col++) {
                    if (buttons[row][col].getText().equals(s)) {
                        d1 = 1 + countNE(row, col, s) + countSW(row, col, s);
                        d2 = 1 + countN(row, col, s) + countS(row, col, s);
                        d3 = 1 + countNW(row, col, s) + countSE(row, col, s);
                        d4 = 1 + countE(row, col, s) + countW(row, col, s);
                        d1 = Math.max(d1, d2);
                        d1 = Math.max(d1,d3);
                        d1 = Math.max(d1, d4);
                    } else {
                        d1 = 0;
                    }
                    c = Math.max(c, d1);
                }
            }
            //System.out.println(s + " " + c);
            return c;
        }

        private int countNE(int row, int col, String s) {
            int count = 0;
            int r = row - 1;
            int c = col - 1;
            while (c >= 0 && r >= 0 && buttons[r][c].getText().equals(s)) {
                count++;
                r--;
                c--;
            }
            return count;
        }

        private int countN(int row, int col, String s) {
            int count = 0;
            int r = row - 1;
            while (r >= 0 && buttons[r][col].getText().equals(s)) {
                count++;
                r--;
            }
            return count;
        }

        private int countNW(int row, int col, String s) {
            int count = 0;
            int r = row - 1;
            int c = col + 1;
            while (r >= 0 && c < COLS && buttons[r][c].getText().equals(s)) {
                count++;
                r--;
                c++;
            }
            return count;
        }

        private int countE(int row, int col, String s) {
            int count = 0;
            int c = col - 1;
            while (c >= 0 && buttons[row][c].getText().equals(s)) {
                count++;
                c--;
            }
            return count;
        }

        private int countW(int row, int col, String s) {
            int count = 0;
            int c = col + 1;
            while(c < COLS && buttons[row][c].getText().equals(s)) {
                count++;
                c++;
            }
            return count;
        }

        private int countSE(int row, int col, String s) {
            int count = 0;
            int r = row + 1;
            int c = col - 1;
            while (r < ROWS && c >= 0 && buttons[r][c].getText().equals(s)) {
                count++;
                r++;
                c--;
            }
            return count;

        }
        private int countS(int row, int col, String s) {
            int count = 0;
            int r = row + 1;
            while(r < ROWS && buttons[r][col].getText().equals(s)) {
                count++;
                r++;
            }
            return count;

        }

        private int countSW(int row, int col, String s) {
            int count = 0;
            int r = row + 1;
            int c = col + 1;
            while( r < ROWS && c < COLS && buttons[r][c].getText().equals(s)) {
                count++;
                r++;
                c++;
            }
            return count;
        }

        public Status getStatus() {
            return this.status;
        }

        private boolean isBlank() {
            boolean blank = true;
            for (int i = 0; i < ROWS; i++) {
                for (int j = 0; j < COLS; j++) {
                    if (!buttons[i][j].getText().equals(" ")) {
                        blank = false;
                        break;
                    }
                }
                if (!blank) break;
            }
            return blank;
        }


        private boolean isFull() {
            boolean full = true;
            for (int i = 0; i < ROWS; i++) {
                for (int j = 0; j < COLS; j++) {
                    if (buttons[i][j].getText().equals(" ")) {
                        full = false;
                        break;
                    }
                }
                if (!full) break;
            }
            return full;
        }



        public void checkStatus() {
            Status currentStatus = getStatus();
            if (count("X") >= TARGET) {
                status = Status.X_WINS;
            } else if (count("O") >= TARGET) {
                status = Status.O_WINS;
            } else if(isFull()) {
                status = Status.DRAW;
            }
            if (!(status == currentStatus)) {
                enableGameButtons(status == Status.IN_PROGRESS);
            }
            statusBar.refreshStatusLabel();
        }

        private void enableGameButtons(boolean enabled) {
            for (int row = 0; row < ROWS; row++) {
                for (int col = 0; col < COLS; col++) {
                    buttons[row][col].setEnabled(enabled);
                }
            }
        }

        private void autoPlay() {

            boolean ready = false;
            int r;
            int c;
            int i = 0;
            //Play square that must be blocked
            for (int row = 0; row < ROWS; row++) {
                for (int col = 0; col < COLS; col++) {
                    if (mustBlock(row, col)) {
                        ready = true;
                        placeMarker(row, col); //Same effect as if the user clicks the button
                        break;
                    }
                }
                if (ready) break;
            }
            //Try to find square that should be blocked if not ready
            for (int row = 0; !ready && row  < ROWS; row++) {
                for (int col = 0; col < COLS; col++) {
                    if (shouldBlock(row, col)) {
                        ready = true;
                        placeMarker(row, col);
                        break;
                    }
                }
                if (ready) break;
            }
            // Try to mark center or in the corners
            if (!ready && getText(ROWS / 2, COLS /2).isBlank()) {
                ready = true;
                placeMarker(ROWS / 2, COLS / 2);
            } else if (!ready && getText(0, 0).isBlank()) {
                ready = true;
                placeMarker( 0, 0);
            } else if (!ready && getText(0, COLS - 1).isBlank()) {
                ready = true;
                placeMarker( 0, COLS - 1);
            } else if (!ready && getText(ROWS -1, COLS - 1).isBlank()) {
                ready = true;
                placeMarker( ROWS -1, COLS - 1);
            } else if (!ready && getText(ROWS - 1, 0).isBlank()) {
                ready = true;
                placeMarker( ROWS - 1, 0);
            }
            //Choose random square to play
            while (!ready) {
                i++;
                //System.out.println(i);
                r = random.nextInt(ROWS);
                c = random.nextInt(COLS);
                if (buttons[r][c].getText().isBlank()) {
                    ready = true;
                    placeMarker(r, c);
                }
                if (i >= 20000) break;
            }


        }

        public void changeMove() {
            if (move.equals("X")) {
                move = "O";
            } else if (move.equals("O")) {
                move = "X";
            } else {
                JOptionPane.showMessageDialog(this, "Invalid move value: " + move);
            }
        }

        public boolean mustBlock(int row, int col) {
            String btnText = buttons[row][col].getText();
            String msg;
            int countDiagonalNESW;
            int countDiagonalSENW;
            int countRow;
            int countCol;
            //System.out.println(row + " " + col);
            if (!btnText.isBlank()) {
                return false;
            } else {
                countDiagonalNESW = countNE(row, col, opponent()) + countSW(row, col, opponent());
                countDiagonalSENW = countSE(row, col, opponent()) + countNW(row, col, opponent());
                countRow = countE(row, col, opponent()) + countW(row, col, opponent());
                countCol = countN(row, col, opponent()) + countS(row, col, opponent());
                /*System.out.println();
                System.out.println("NE-SW: " + countDiagonalNESW);
                System.out.println("SE-NW: " + countDiagonalSENW);
                System.out.println("Row: " + countRow);
                System.out.println("Col: " + countCol);
                 */

                if (countDiagonalNESW >= TARGET - 1) {
                    return true;
                } else if (countDiagonalSENW >= TARGET - 1) {
                    return true;
                } else if (countRow >= TARGET - 1) {
                    return true;
                } else if (countCol >= TARGET - 1) {
                    return true;
                } else {
                    return false;
                }
            }
        }

        public boolean shouldBlock(int row, int col) {
            String btnText = buttons[row][col].getText();
            String msg;
            int countDiagonalNESW;
            int countDiagonalSENW;
            int countRow;
            int countCol;
            int sum;
            if (!btnText.isBlank()) {
                return false;
            } else {
                countDiagonalNESW = countNE(row, col, opponent()) + countSW(row, col, opponent());
                countDiagonalSENW = countSE(row, col, opponent()) + countNW(row, col, opponent());
                countRow = countE(row, col, opponent()) + countW(row, col, opponent());
                countCol = countN(row, col, opponent()) + countS(row, col, opponent());
                sum = countDiagonalNESW + countDiagonalSENW + countRow + countCol;
                if (sum >= TARGET - 1) {
                    return true;
                } else {
                    return false;
                }
            }
        }


        private void placeMarker(int row, int col) {
            buttons[row][col].doClick();
        }

        public void setButtonTextMove(int row, int col) {
            buttons[row][col].setText(move);
        }

        public String getText(int row, int col) {
            return buttons[row][col].getText();
        }

        public String opponent() {
            //Returns the sign of the player that is not active
            if (move.equals("X")) {
                return "O";
            } else if (move.equals("O")) {
                return "X";
            } else {
                JOptionPane.showMessageDialog(this, "Warning, invalid move: " + move);
                move = "X";
                return "O";
            }
        }


    }
  learner_created: true
- name: src/tictactoe/GamePadStatusBar.java
  visible: true
  text: |-
    package tictactoe;

    import javax.swing.*;
    import java.awt.*;

    public class GamePadStatusBar extends JPanel {
        private final int HEIGHT;
        private final GamePad gamePad;
        private final JLabel lblStatus;

        public GamePadStatusBar(int height, GamePad gamePad) throws HeadlessException {
            this.HEIGHT = height;
            this.gamePad = gamePad;
            setSize(gamePad.getWidth(), height);

            LayoutManager lm = new FlowLayout();
            setLayout(lm);

            lblStatus = new JLabel();

            refreshStatusLabel();

            lblStatus.setName("LabelStatus");



            add(lblStatus);


        }

        public void refreshStatusLabel() {
            String text = "";
            switch (gamePad.getStatus()) {
                case DRAW:
                    text = "Draw";
                    break;
                case O_WINS:
                    if (gamePad.isRobot("O")) {
                        text = "The Robot ";
                    } else {
                        text = "The Human ";
                    }
                    text += "Player (O) wins";
                    break;
                case X_WINS:
                    if (gamePad.isRobot("X")) {
                        text = "The Robot ";
                    } else {
                        text = "The Human ";
                    }
                    text += "Player (X) wins";
                    break;
                case IN_PROGRESS:
                    text = "The turn of ";
                    if (gamePad.isRobot(gamePad.getMove())) {
                        text += "Robot ";
                    } else {
                        text += "Human ";
                    }
                    text += "Player (" + gamePad.getMove() +")";
                    break;
                case NOT_STARTED:
                    text = "Game is not started";
                    break;
                default:
                    text = "Error";
            }
            lblStatus.setText(text);
        }
    }
  learner_created: true
- name: src/tictactoe/AutoPlayer.java
  visible: true
  text: |-
    package tictactoe;

    import javax.swing.*;
    import java.util.Random;

    public class AutoPlayer extends SwingWorker {

        private GamePad gamePad;
        private String move = new String("X");
        private Random random = new Random();
        private final int ROWS;
        private final int COLS;
        private final long SLEEP_TIME_MS = 2000L;

        public AutoPlayer(GamePad gamePad) {
            this.gamePad = gamePad;
            this.ROWS = gamePad.getROWS();
            this.COLS = gamePad.getCOLS();
        }

        @Override
        protected Object doInBackground() throws Exception {
            move = "X";
            gamePad.checkStatus();

            while (gamePad.getStatus() == GamePad.Status.IN_PROGRESS) {
                play();
                gamePad.checkStatus();
                if (gamePad.getStatus() == GamePad.Status.IN_PROGRESS) {
                    gamePad.changeMove();
                    pause();
                }
            }
            return null;
        }

        private void play() {

            boolean ready = false;
            int r;
            int c;
            int i = 0;
            // Check for positions that must be blocked
            for (int row = 0; row < ROWS; row++) {
                for (int col = 0; col < COLS; col++) {
                    if (gamePad.mustBlock(row, col)) {
                        ready = true;
                        gamePad.setButtonTextMove(row, col);
                        break;
                    }
                }
                if (ready) break;
            }
            // Check fpr positions that should be blocked
            for (int row = 0; !ready && row < ROWS; row++) {
                for (int col = 0; col < COLS; col++) {
                    if (gamePad.shouldBlock(row, col)) {
                        ready = true;
                        gamePad.setButtonTextMove(row, col);
                        break;
                    }
                }
                if (ready) break;
            }
            // Try to mark center or in the corners
            if (!ready && gamePad.getText(ROWS / 2, COLS /2).isBlank()) {
                ready = true;
                gamePad.setButtonTextMove(ROWS / 2, COLS / 2);
            } else if (!ready && gamePad.getText(0, 0).isBlank()) {
                ready = true;
                gamePad.setButtonTextMove(0, 0);
            } else if (!ready && gamePad.getText(0, COLS - 1).isBlank()) {
                ready = true;
                gamePad.setButtonTextMove(0, COLS - 1);
            } else if (!ready && gamePad.getText(ROWS -1, COLS - 1).isBlank()) {
                ready = true;
                gamePad.setButtonTextMove(ROWS -1, COLS - 1);
            } else if (!ready && gamePad.getText(ROWS - 1, 0).isBlank()) {
                ready = true;
                gamePad.setButtonTextMove(ROWS - 1, 0);
            }
            //If not possible mark random free square
            while (!ready) {
                i++;
                //System.out.println(i);
                r = random.nextInt(ROWS);
                c = random.nextInt(COLS);
                if (gamePad.getText(r, c).isBlank()) {
                    ready = true;
                    gamePad.setButtonTextMove(r, c);
                }
                if (i >= 20000) break;
            }
        }

        private void pause() {
            try {
                Thread.sleep(SLEEP_TIME_MS);
            } catch (InterruptedException ie) {
                JOptionPane.showMessageDialog(gamePad, "Warning, interrupted exception!");
            }
        }
    }
  learner_created: true
- name: src/tictactoe/ButtonActionListener.java
  visible: true
  text: |-
    package tictactoe;

    import javax.swing.*;
    import java.awt.event.ActionEvent;
    import java.awt.event.ActionListener;


    public class ButtonActionListener implements ActionListener {

        JButton button;
        GamePad gamePad;

        public ButtonActionListener(JButton button, GamePad gamePad) {
            this.button = button;
            this.gamePad = gamePad;
        }


        @Override
        public void actionPerformed(ActionEvent e) {
            GamePad.Status status = gamePad.getStatus();
            if (status == GamePad.Status.IN_PROGRESS) {
                if (button.getText().isBlank()) {
                    button.setText(gamePad.getMove());
                    gamePad.changeMove(); //next player!
                }
                gamePad.checkStatus();
                status = gamePad.getStatus();

                if (status == GamePad.Status.IN_PROGRESS) {
                    gamePad.play();
                }

            }
        }

    }
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/12897#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Sat, 21 May 2022 15:21:06 UTC
record: -1
