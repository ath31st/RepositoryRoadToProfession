type: edu
files:
- name: build.gradle
  visible: true
  text: |-
    plugins {
        id 'java'
        id 'org.springframework.boot' version '2.3.1.RELEASE'
        id 'io.spring.dependency-management' version '1.0.9.RELEASE'
    }

    repositories {
        mavenCentral()
    }

    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter'
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
        implementation 'org.springframework.boot:spring-boot-starter-web'
        implementation group: 'org.hibernate', name: 'hibernate-validator', version: '6.1.0.Final'
    }
  learner_created: false
- name: src/account/AccountServiceApplication.java
  visible: true
  text: |-
    package account;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class AccountServiceApplication {

        public static void main(String[] args) {
            SpringApplication.run(AccountServiceApplication.class, args);
        }

    }
  learner_created: false
- name: src/resources/application.properties
  visible: true
  text: |-
    server.port=28852
    management.endpoints.web.exposure.include=*
    management.endpoint.shutdown.enabled=true
    spring.jackson.serialization.INDENT_OUTPUT=true
  learner_created: false
- name: test/AccountServiceTest.java
  visible: false
  text: |
    import account.AccountServiceApplication;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.dynamic.input.DynamicTesting;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.mocks.web.request.HttpRequest;
    import org.hyperskill.hstest.stage.SpringTest;
    import org.hyperskill.hstest.testcase.CheckResult;

    import javax.net.ssl.*;
    import java.security.cert.X509Certificate;

    public class AccountServiceTest extends SpringTest {
      public AccountServiceTest() {
        super(AccountServiceApplication.class, "../service_db.mv.db");
      }

      SSLSocket socket;
      java.security.cert.X509Certificate[] chain;

      // Warning!!! Only for testing reason, trust all certificates!
      TrustManager[] trustAllCerts = new TrustManager[] {
              new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                  return new java.security.cert.X509Certificate[0];
                }
                public void checkClientTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
                public void checkServerTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
              }
      };

      // Test SSL
      public CheckResult checkCertificateName(String nameCN) {
        try {
          SSLContext sc = SSLContext.getInstance("SSL");
          //ТАК нельзя!!! доверяем всем сертификатам, только для тестирования и разработки!!!
          sc.init(null, trustAllCerts, new java.security.SecureRandom());
          SSLSocketFactory factory = sc.getSocketFactory();
          HttpRequest request = get("");
          socket = (SSLSocket) factory.createSocket(request.getHost(), request.getPort());
          getCertificates();
          if (findCert(nameCN)) {
            return CheckResult.correct();
          } else {
            throw new WrongAnswer("Not found certificate with CN - " + nameCN);
          }
        } catch (Exception e) {
          e.printStackTrace();
          System.out.println("Connection not found");
          throw new WrongAnswer("Can't establish https connection!");
        }
      }

      // Get certificate chain
      public void getCertificates() {
        try {
          chain = (X509Certificate[]) socket.getSession().getPeerCertificates();
        } catch (SSLPeerUnverifiedException e) {
          e.printStackTrace();
          System.out.println(e.toString());
        }
      }


      // Searching certificate by Common Name
      public boolean findCert(String subject) {
        for (java.security.cert.X509Certificate c : chain) {
          String subjectName = c.getSubjectDN().getName();
          System.out.println(subjectName + " " + c.getSigAlgName());
          if (subjectName.contains("CN=" + subject)) {
            return true;
          }
        }
        return false;
      }

      @DynamicTest
      DynamicTesting[] dt = new DynamicTesting[]{

              // Check certificate name
              () -> checkCertificateName("accountant_service"),
      };
    }
  learner_created: false
- name: src/account/controller/SecurityController.java
  visible: true
  text: |
    package account.controller;

    import account.entites.Event;
    import account.service.SecurityService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    import java.util.List;

    @RestController
    @RequestMapping("/api")
    public class SecurityController {
        @Autowired
        SecurityService securityService;

        @GetMapping("/security/events")
        public ResponseEntity<List<Event>> getEvents() {
            return securityService.getEvents();
        }
    }
  learner_created: true
- name: src/account/dto/UserStatusChangeRequest.java
  visible: true
  text: |
    package account.dto;

    public class UserStatusChangeRequest {
        private String user;
        private String operation;

        public String getUser() {
            return user;
        }

        public void setUser(String user) {
            this.user = user;
        }

        public String getOperation() {
            return operation;
        }

        public void setOperation(String operation) {
            this.operation = operation;
        }
    }
  learner_created: true
- name: src/account/dto/EmployeePaymentResponse.java
  visible: true
  text: |
    package account.dto;

    import org.springframework.stereotype.Component;

    @Component
    public class EmployeePaymentResponse {
        private String name;
        private String lastname;
        private String  period;
        private String salary;

        public EmployeePaymentResponse() {
        }

        public EmployeePaymentResponse(String name, String lastname, String period, String salary) {
            this.name = name;
            this.lastname = lastname;
            this.period = period;
            this.salary = salary;
        }

        public void setName(String name) {
            this.name = name;
        }

        public void setLastname(String lastname) {
            this.lastname = lastname;
        }

        public void setPeriod(String  period) {
            this.period = period;
        }

        public void setSalary(String salary) {
            this.salary = salary;
        }

        public String getName() {
            return name;
        }

        public String getLastname() {
            return lastname;
        }

        public String getPeriod() {
            return period;
        }

        public String getSalary() {
            return salary;
        }
    }
  learner_created: true
- name: src/account/service/PaymentService.java
  visible: true
  text: |
    package account.service;

    import account.entites.Payment;
    import account.entites.User;
    import account.exceptionhandler.exception.*;
    import account.repository.PaymentRepository;
    import account.repository.UserRepository;
    import account.dto.EmployeePaymentResponse;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.stereotype.Service;

    import java.time.DateTimeException;
    import java.time.YearMonth;
    import java.time.format.DateTimeFormatter;
    import java.util.*;

    @Service
    public class PaymentService {
        @Autowired
        private PaymentRepository paymentRepository;
        @Autowired
        private UserRepository userRepository;

        public ResponseEntity<Map<String, String>> addPaymentsIntoDb(List<Payment> paymentList) {
            checkValidatePayment(paymentList);
            paymentList.forEach(paymentRepository::save);
            return ResponseEntity.ok().body(Map.of("status", "Added successfully!"));
        }

        public ResponseEntity<Map<String, String>> putPaymentChanges(Payment payment) {
            checkExistsEmployee(payment);
            checkCorrectSalary(payment);
            Payment paymentFromDb = paymentRepository
                    .findPaymentByEmployeeIgnoreCaseAndPeriod(payment.getEmployee(), payment.getPeriod())
                    .orElseThrow(EmployeeNotFoundException::new);
            paymentFromDb.setSalary(payment.getSalary());
            paymentRepository.save(paymentFromDb);
            return ResponseEntity.ok().body(Map.of("status", "Updated successfully!"));
        }

        public ResponseEntity getPaymentForPeriod(String period, User user) {
            if (period == null) {
                List<Payment> payments = paymentRepository.findPaymentByEmployeeIgnoreCase(user.getEmail());
                payments.sort(Comparator.comparing(Payment::getPeriod).reversed());
                List<EmployeePaymentResponse> responses = new ArrayList<>();
                for (Payment payment : payments) {
                    responses.add(createResponse(payment, user));
                }
                return ResponseEntity.ok().body(responses);
            } else {
                Payment payment = paymentRepository.findPaymentByEmployeeIgnoreCaseAndPeriod(user.getEmail(), getYearMonthFromString(period))
                        .orElseThrow(PaymentNotFoundException::new);
                EmployeePaymentResponse response = createResponse(payment, user);
                return ResponseEntity.ok().body(response);
            }
        }

        private EmployeePaymentResponse createResponse(Payment payment, User user) {
            DateTimeFormatter english = DateTimeFormatter.ofPattern("MMMM-yyyy", Locale.ENGLISH);
            EmployeePaymentResponse response = new EmployeePaymentResponse();
            response.setName(user.getUsername());
            response.setLastname(user.getLastname());
            response.setPeriod(payment.getPeriod().format(english));
            response.setSalary(String.format("%d dollar(s) %d cent(s)", payment.getSalary() / 100, payment.getSalary() % 100));
            return response;
        }


        private List<Payment> getAllPaymentsByEmployee(String emailEmployee) {
            return paymentRepository.findPaymentByEmployeeIgnoreCase(emailEmployee);
        }

        private void checkValidatePayment(List<Payment> paymentList) {
            for (Payment payment : paymentList) {
                checkCorrectSalary(payment);
                checkExistsEmployee(payment);
                checkDuplicatePayments(payment);
            }
        }

        private void checkCorrectSalary(Payment payment) {
            if (payment.getSalary() < 0) {
                throw new SalaryException();
            }
        }

        private void checkExistsEmployee(Payment payment) {
            if (userRepository.findUserByEmailIgnoreCase(payment.getEmployee()).isEmpty()) {
                throw new EmployeeNotFoundException();
            }
        }

        private void checkDuplicatePayments(Payment payment) {
            List<Payment> payments = getAllPaymentsByEmployee(payment.getEmployee());
            if (payments.stream().anyMatch(payment::equals)) {
                throw new DuplicatePaymentException();
            }
        }

        private YearMonth getYearMonthFromString(String period) {
            YearMonth per = null;
            try {
                per = YearMonth.parse(period, DateTimeFormatter.ofPattern("MM-yyyy"));
            } catch (DateTimeException e) {
                throw new WrongPeriodException();
            }
            return per;
        }
    }
  learner_created: true
- name: src/account/config/SecurityConfig.java
  visible: true
  text: |
    package account.config;

    import account.exceptionhandler.RestAccessDeniedHandler;
    import account.util.Role;
    import account.exceptionhandler.RestAuthenticationEntryPoint;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
    import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
    import org.springframework.security.config.http.SessionCreationPolicy;

    @Configuration
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
        @Autowired
        DaoAuthenticationProvider authenticationProvider;
        @Autowired
        private RestAuthenticationEntryPoint restAuthenticationEntryPoint;
        @Autowired
        private RestAccessDeniedHandler restAccessDeniedHandler;

        public void configure(HttpSecurity http) throws Exception {
            http.httpBasic()
                    .authenticationEntryPoint(restAuthenticationEntryPoint)// Handle auth error
                    .and()
                    .exceptionHandling().accessDeniedHandler(restAccessDeniedHandler)
                    .and()
                    .csrf().disable().headers().frameOptions().disable() // for Postman, the H2 console
                    .and()
                    .authorizeRequests()
                    .antMatchers("/api/auth/singup").permitAll()
                    .antMatchers("/api/auth/changepass").hasAnyAuthority(Role.ROLE_ADMINISTRATOR.name()
                            ,Role.ROLE_USER.name()
                            ,Role.ROLE_ACCOUNTANT.name())
                    .antMatchers("/api/empl/payment").hasAnyAuthority(Role.ROLE_USER.name()
                            ,Role.ROLE_ACCOUNTANT.name())
                    .antMatchers("/api/acct/payments").hasAuthority(Role.ROLE_ACCOUNTANT.name())
                    .antMatchers("/api/security/events/*").hasAuthority(Role.ROLE_AUDITOR.name())
                    .antMatchers("/api/admin/**").hasAuthority(Role.ROLE_ADMINISTRATOR.name())
                    .and()
                    .sessionManagement()
                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS); // no session
        }

    //    @Override
    //    public void configure(AuthenticationManagerBuilder auth) {
    //        auth.authenticationProvider(authenticationProvider);
    //    }
    }
  learner_created: true
- name: src/account/service/RoleService.java
  visible: true
  text: |
    package account.service;

    import account.entites.User;
    import account.repository.UserRepository;
    import account.util.Operation;
    import account.util.Role;
    import account.dto.RoleChangeRequest;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.stereotype.Service;
    import org.springframework.web.server.ResponseStatusException;

    import java.util.*;

    @Service
    public class RoleService {
        @Autowired
        private UserRepository userRepository;
        @Autowired
        SecurityService securityService;

        public ResponseEntity<User> changeUserRole(RoleChangeRequest roleChangeRequest) {
            User user = userRepository.findUserByEmailIgnoreCase(roleChangeRequest.getUser()).orElseThrow(
                    () -> new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found!")
            );

            String stringRoleFromReq = "ROLE_" + roleChangeRequest.getRole().toUpperCase();
            String stringOperationFromReq = roleChangeRequest.getOperation().toUpperCase();

            checkExistingRole(stringRoleFromReq);
            checkExistingOperation(stringOperationFromReq);

            Role roleFromReq = Role.valueOf(stringRoleFromReq);
            Operation operationFromReq = Operation.valueOf(stringOperationFromReq);

            if (operationFromReq.equals(Operation.GRANT)) {
                grantOperation(user, roleFromReq);
                securityService.createGrantRoleEvent(user, roleChangeRequest.getRole().toUpperCase());
            } else if (operationFromReq.equals(Operation.REMOVE)) {
                removeOperation(user, roleFromReq);
                securityService.createRemoveRoleEvent(user, roleChangeRequest.getRole().toUpperCase());
            }
            userRepository.save(user);
            return ResponseEntity.ok().body(user);
        }

        private void grantOperation(User user, Role roleFromReq) {
            List<Role> roles = user.getRoles();

            checkCompatibleRoles(roles, roleFromReq);
            checkExistingRoleUserForGrantOperation(user, roleFromReq);

            roles.add(roleFromReq);
            roles.sort(Comparator.reverseOrder());
            user.setRoles(roles);
        }

        private void removeOperation(User user, Role roleFromReq) {

            checkAdminRole(roleFromReq);
            checkExistingRoleUserForRemoveOperation(user, roleFromReq);
            checkCountRolesUser(user);

            List<Role> roles = user.getRoles();
            roles.remove(roleFromReq);
            user.setRoles(roles);
        }

        private void checkExistingRole(String roleFromReq) {
            if (Arrays.stream(Role.values()).noneMatch(role -> role.name().equals(roleFromReq)))
                throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Role not found!");
        }


        private void checkExistingOperation(String operationFromReq) {
            if (Arrays.stream(Operation.values()).noneMatch(operation -> operation.name().equals(operationFromReq)))
                throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Operation not found!");
        }


        private void checkExistingRoleUserForRemoveOperation(User user, Role roleFromReq) {
            if (!user.getRoles().contains(roleFromReq)) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "The user does not have a role!");
            }
        }

        private void checkExistingRoleUserForGrantOperation(User user, Role roleFromReq) {
            if (user.getRoles().contains(roleFromReq)) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "The user already have this role!");
            }
        }

        private void checkCountRolesUser(User user) {
            if (user.getRoles().size() == 1) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "The user must have at least one role!");
            }
        }

        private void checkAdminRole(Role roleFromReq) {
            if (roleFromReq.equals(Role.ROLE_ADMINISTRATOR)) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Can't remove ADMINISTRATOR role!");
            }
        }

        private void checkCompatibleRoles(List<Role> roles, Role roleFromReq) {
            if ((roles.contains(Role.ROLE_AUDITOR) | roles.contains(Role.ROLE_ACCOUNTANT) | roles.contains(Role.ROLE_USER)) & roleFromReq.equals(Role.ROLE_ADMINISTRATOR)) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "The user cannot combine administrative and business roles!");
            } else if (roles.contains(Role.ROLE_ADMINISTRATOR) & (roleFromReq.equals(Role.ROLE_ACCOUNTANT) | roleFromReq.equals(Role.ROLE_USER) | roleFromReq.equals(Role.ROLE_AUDITOR))) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "The user cannot combine administrative and business roles!");
            }
        }
    }
  learner_created: true
- name: src/account/repository/FailedLoginCounterRepository.java
  visible: true
  text: |
    package account.repository;

    import account.entites.FailedLoginCounter;
    import org.springframework.data.repository.CrudRepository;
    import org.springframework.stereotype.Repository;

    import java.util.Optional;
    @Repository
    public interface FailedLoginCounterRepository extends CrudRepository<FailedLoginCounter, Long> {
        Optional<FailedLoginCounter> findByEmailIgnoreCase(String email);
    }
  learner_created: true
- name: src/account/controller/AuthController.java
  visible: true
  text: |
    package account.controller;

    import account.dto.ChangeUserPasswordResponse;
    import account.entites.User;
    import account.service.UserService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    import javax.validation.Valid;
    import java.util.Map;

    @RestController
    @RequestMapping("/api/auth")
    public class AuthController {
        @Autowired
        private UserService userService;

        @PostMapping("/signup")
        public ResponseEntity<User> registerUser(@Valid @RequestBody User user) {
            return ResponseEntity.ok().body(userService.registerNewUser(user));
        }

        @PostMapping("/changepass")
        public ResponseEntity<ChangeUserPasswordResponse> changeUserPass(@RequestBody Map<String,String> newPassword, @AuthenticationPrincipal User user) {
            return userService.changePassword(newPassword.get("new_password"),user);
        }
    }
  learner_created: true
- name: src/account/controller/BusinessFuncController.java
  visible: true
  text: |
    package account.controller;

    import account.entites.Payment;
    import account.service.PaymentService;
    import account.service.UserService;
    import account.entites.User;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.core.annotation.AuthenticationPrincipal;
    import org.springframework.web.bind.annotation.*;

    import java.util.List;

    @RestController
    @RequestMapping("/api")
    class BusinessFuncController {

        @Autowired
        private UserService userService;
        @Autowired
        private PaymentService paymentService;


        @GetMapping("/empl/payment")
        public ResponseEntity getPaymentForPeriod(@RequestParam(value = "period",required = false) String period, @AuthenticationPrincipal User user) {
            return paymentService.getPaymentForPeriod(period, user);
        }

        @PostMapping("/acct/payments")
        public ResponseEntity uploadsPayrolls(@RequestBody List<Payment> paymentList) {
            return paymentService.addPaymentsIntoDb(paymentList);
        }

        @PutMapping("/acct/payments")
        public ResponseEntity updatePaymentinfo(@RequestBody Payment payment) {
            return paymentService.putPaymentChanges(payment);
        }
    }
  learner_created: true
- name: src/account/service/FailedLoginService.java
  visible: true
  text: |
    package account.service;

    import account.entites.FailedLoginCounter;
    import account.repository.FailedLoginCounterRepository;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    @Service
    public class FailedLoginService {
        @Autowired
        private FailedLoginCounterRepository failedLoginCounterRepository;

        public void resetCounterFailedLogin(String email) {
            FailedLoginCounter counter = failedLoginCounterRepository.findByEmailIgnoreCase(email).orElse(new FailedLoginCounter());
            counter.setCount(1);
            failedLoginCounterRepository.save(counter);
        }

        public void failedLoginUpdate(String email) {
            FailedLoginCounter counter = failedLoginCounterRepository.findByEmailIgnoreCase(email).orElse(new FailedLoginCounter());
            counter.setEmail(email);
            counter.setCount(counter.getCount() + 1);
            failedLoginCounterRepository.save(counter);
        }

        public int getCountFailedLogin(String email) {
            FailedLoginCounter counter = failedLoginCounterRepository.findByEmailIgnoreCase(email).orElse(new FailedLoginCounter());
            System.out.println(email + " " + counter.getCount());
            return counter.getCount();
        }

    }
  learner_created: true
- name: src/account/dto/ChangeUserPasswordResponse.java
  visible: true
  text: |
    package account.dto;

    public class ChangeUserPasswordResponse {
        private String email;
        private String status;

        public ChangeUserPasswordResponse() {
        }

        public ChangeUserPasswordResponse(String email, String status) {
            this.email = email;
            this.status = status;
        }

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        public String getStatus() {
            return status;
        }

        public void setStatus(String status) {
            this.status = status;
        }
    }
  learner_created: true
- name: src/account/repository/PaymentRepository.java
  visible: true
  text: |
    package account.repository;

    import account.entites.Payment;
    import org.springframework.data.repository.CrudRepository;
    import org.springframework.stereotype.Repository;

    import java.time.YearMonth;
    import java.util.List;
    import java.util.Optional;

    @Repository
    public interface PaymentRepository extends CrudRepository<Payment, Long> {
        List<Payment> findPaymentByEmployeeIgnoreCase(String email);

        Optional<Payment> findPaymentByEmployeeIgnoreCaseAndPeriod(String email, YearMonth period);

    }
  learner_created: true
- name: src/account/util/Operation.java
  visible: true
  text: |
    package account.util;

    public enum Operation {
        GRANT,
        REMOVE,
        LOCK,
        UNLOCK
    }
  learner_created: true
- name: src/account/entites/User.java
  visible: true
  text: |
    package account.entites;

    import account.util.Role;
    import com.fasterxml.jackson.annotation.JsonIgnore;
    import com.fasterxml.jackson.annotation.JsonProperty;
    import org.springframework.security.core.GrantedAuthority;
    import org.springframework.security.core.authority.SimpleGrantedAuthority;
    import org.springframework.security.core.userdetails.UserDetails;

    import javax.persistence.*;
    import javax.validation.constraints.NotBlank;
    import javax.validation.constraints.NotEmpty;
    import javax.validation.constraints.NotNull;
    import javax.validation.constraints.Pattern;
    import java.util.*;

    @Entity
    public class User implements UserDetails {
        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        @Column(name = "id", nullable = false)
        private Long id;
        @JsonProperty("name")
        @NotEmpty
        private String username;
        @NotEmpty
        private String lastname;
        @Pattern(regexp = "^([\\w-]+(?:\\.[\\w-]+)*)@(acme.com)$")
        @NotBlank
        @NotNull
        private String email;
        @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
        @NotNull
        @NotBlank
        private String password;

        @Enumerated(EnumType.STRING)
        @ElementCollection(fetch = FetchType.EAGER)
        private List<Role> roles;
        @JsonIgnore
        private boolean accountNonExpired;
        @JsonIgnore
        private boolean accountNonLocked;
        @JsonIgnore
        private boolean credentialsNonExpired;
        @JsonIgnore
        private boolean enabled;

        public User() {
            this.accountNonExpired = true;
            this.accountNonLocked = true;
            this.credentialsNonExpired = true;
            this.enabled = true;
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public String getUsername() {
            return username;
        }

        @Override
        public boolean isAccountNonExpired() {
            return accountNonExpired;
        }

        @Override
        public boolean isAccountNonLocked() {
            return accountNonLocked;
        }

        @Override
        public boolean isCredentialsNonExpired() {
            return credentialsNonExpired;
        }

        @Override
        public boolean isEnabled() {
            return enabled;
        }

        public void setUsername(String username) {
            this.username = username;
        }

        public String getLastname() {
            return lastname;
        }

        public void setLastname(String lastname) {
            this.lastname = lastname;
        }

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        public void grantAuthority(Role authority) {
            if (roles == null) roles = new LinkedList<>();
            roles.add(authority);
        }
        @JsonIgnore
        @Override
        public List<GrantedAuthority> getAuthorities() {
            List<GrantedAuthority> authorities = new ArrayList<>();
            roles.forEach(role -> authorities.add(new SimpleGrantedAuthority(role.toString())));
            return authorities;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }

        public List<Role> getRoles() {
            return roles;
        }

        public void setRoles(List<Role> roles) {
            this.roles = roles;
        }

        public void setAccountNonLocked(boolean accountNonLocked) {
            this.accountNonLocked = accountNonLocked;
        }
    }
  learner_created: true
- name: src/account/config/BeanConfig.java
  visible: true
  text: |
    package account.config;

    import account.entites.Event;
    import account.service.UserService;
    import account.util.Action;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.security.web.access.AccessDeniedHandler;

    import java.time.LocalDateTime;
    import java.util.List;

    @Configuration
    public class BeanConfig {
        @Autowired
        private UserService userService;

        @Bean
        public DaoAuthenticationProvider authenticationProvider() {
            DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
            provider.setPasswordEncoder(getEncoder());
            provider.setUserDetailsService(userService);
            return provider;
        }

        @Bean
        public PasswordEncoder getEncoder() {
            return new BCryptPasswordEncoder();
        }

        @Bean
        public List<String> getBreachedPasswords() {
            return List.of("PasswordForJanuary", "PasswordForFebruary", "PasswordForMarch", "PasswordForApril",
                    "PasswordForMay", "PasswordForJune", "PasswordForJuly", "PasswordForAugust",
                    "PasswordForSeptember", "PasswordForOctober", "PasswordForNovember", "PasswordForDecember");
        }

    }
  learner_created: true
- name: src/account/repository/EventRepository.java
  visible: true
  text: |
    package account.repository;

    import account.entites.Event;
    import org.springframework.data.repository.CrudRepository;

    public interface EventRepository extends CrudRepository<Event, Long> {
    }
  learner_created: true
- name: src/account/entites/FailedLoginCounter.java
  visible: true
  text: |
    package account.entites;

    import org.hibernate.Hibernate;

    import javax.persistence.*;
    import java.util.Objects;

    @Entity
    public class FailedLoginCounter {
        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        @Column(name = "id", nullable = false)
        private Long id;
        @Column(unique = true)
        private String email;
        @Column
        private int count;

        public FailedLoginCounter() {
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        public int getCount() {
            return count;
        }

        public void setCount(int count) {
            this.count = count;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || Hibernate.getClass(this) != Hibernate.getClass(o)) return false;
            FailedLoginCounter counter = (FailedLoginCounter) o;
            return id != null && Objects.equals(id, counter.id);
        }

        @Override
        public int hashCode() {
            return getClass().hashCode();
        }
    }
  learner_created: true
- name: src/account/util/Action.java
  visible: true
  text: |
    package account.util;

    public enum Action {
        DEFAULT_ACTION,
        CREATE_USER,
        CHANGE_PASSWORD,
        ACCESS_DENIED,
        LOGIN_FAILED,
        GRANT_ROLE,
        REMOVE_ROLE,
        LOCK_USER,
        UNLOCK_USER,
        DELETE_USER,
        BRUTE_FORCE
    }
  learner_created: true
- name: src/account/util/Role.java
  visible: true
  text: |-
    package account.util;

    public enum Role {
        ROLE_USER,
        ROLE_ADMINISTRATOR,
        ROLE_ACCOUNTANT,
        ROLE_AUDITOR
    }
  learner_created: true
- name: src/account/dto/RoleChangeRequest.java
  visible: true
  text: |
    package account.dto;

    public class RoleChangeRequest {
        private String user;
        private String role;
        private String operation;

        public RoleChangeRequest() {
        }

        public String getUser() {
            return user;
        }

        public void setUser(String user) {
            this.user = user;
        }

        public String getRole() {
            return role;
        }

        public void setRole(String role) {
            this.role = role;
        }

        public String getOperation() {
            return operation;
        }

        public void setOperation(String operation) {
            this.operation = operation;
        }
    }
  learner_created: true
- name: src/account/dto/DeleteUserResponse.java
  visible: true
  text: |
    package account.dto;

    public class DeleteUserResponse {
        private String user;
        private String status;

        public DeleteUserResponse() {
        }

        public DeleteUserResponse(String user, String status) {
            this.user = user;
            this.status = status;
        }

        public String getUser() {
            return user;
        }

        public void setUser(String user) {
            this.user = user;
        }

        public String getStatus() {
            return status;
        }

        public void setStatus(String status) {
            this.status = status;
        }
    }
  learner_created: true
- name: src/account/repository/UserRepository.java
  visible: true
  text: |-
    package account.repository;

    import account.entites.User;
    import org.springframework.data.repository.CrudRepository;
    import org.springframework.stereotype.Repository;

    import java.util.Optional;

    @Repository
    public interface UserRepository extends CrudRepository<User, Long> {
        Optional<User> findUserByEmailIgnoreCase(String email);
    }
  learner_created: true
- name: src/account/controller/ServiceFuncController.java
  visible: true
  text: |
    package account.controller;

    import account.dto.DeleteUserResponse;
    import account.dto.UserStatusChangeRequest;
    import account.dto.UserStatusChangeResponse;
    import account.entites.User;
    import account.service.RoleService;
    import account.service.UserService;
    import account.dto.RoleChangeRequest;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.*;

    import javax.validation.Valid;
    import java.util.List;

    @RestController
    @RequestMapping("/api/admin")
    public class ServiceFuncController {

        @Autowired
        private UserService userService;
        @Autowired
        private RoleService roleService;

        @PutMapping("/user/role")
        public ResponseEntity<User> changeUserRole(@RequestBody @Valid RoleChangeRequest roleChangeRequest) {
            return roleService.changeUserRole(roleChangeRequest);
        }

        @DeleteMapping("/user/{email}")
        public ResponseEntity<DeleteUserResponse> deleteUser(@PathVariable String email) {
            return userService.deleteUser(email);
        }

        @GetMapping("/user")
        public ResponseEntity<List<User>> getUsersInfo() {
            return userService.getUsersInfo();
        }

        @PutMapping("/user/access")
        public ResponseEntity<UserStatusChangeResponse> changeUserStatus(@RequestBody UserStatusChangeRequest request) {
            return userService.changeUserStatus(request);
        }
    }
  learner_created: true
- name: src/account/entites/Payment.java
  visible: true
  text: |
    package account.entites;

    import account.util.YearMonthDateAttributeConverter;
    import com.fasterxml.jackson.annotation.JsonFormat;

    import javax.persistence.*;
    import java.time.YearMonth;
    import java.util.Objects;

    @Entity
    public class Payment {
        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        @Column(name = "id", nullable = false)
        private Long id;
        @Column
        private String employee;
        @Column
        @Convert(converter = YearMonthDateAttributeConverter.class)
        @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "MM-yyyy")
        private YearMonth period;
        @Column
        private Long salary;


        public Payment() {
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }


        public String getEmployee() {
            return employee;
        }

        public void setEmployee(String employee) {
            this.employee = employee;
        }

        public YearMonth getPeriod() {
            return period;
        }

        public void setPeriod(YearMonth period) {
            this.period = period;
        }

        public Long getSalary() {
            return salary;
        }

        public void setSalary(Long salary) {
            this.salary = salary;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Payment payment = (Payment) o;
            return Objects.equals(employee, payment.employee) && Objects.equals(period, payment.period);
        }

        @Override
        public int hashCode() {
            return Objects.hash(employee, period);
        }
    }
  learner_created: true
- name: src/account/util/YearMonthDateAttributeConverter.java
  visible: true
  text: |-
    package account.util;

    import javax.persistence.AttributeConverter;
    import javax.persistence.Converter;
    import java.sql.Date;
    import java.time.Instant;
    import java.time.YearMonth;
    import java.time.ZoneId;

    @Converter
    public class YearMonthDateAttributeConverter
            implements AttributeConverter<YearMonth, Date> {

        @Override
        public Date convertToDatabaseColumn(
                YearMonth attribute) {
            if (attribute != null) {
                return Date.valueOf(
                        attribute.atDay(1)
                );
            }
            return null;
        }

        @Override
        public YearMonth convertToEntityAttribute(
                Date dbData) {
            if (dbData != null) {
                return YearMonth.from(
                        Instant
                                .ofEpochMilli(dbData.getTime())
                                .atZone(ZoneId.systemDefault())
                                .toLocalDate()
                );
            }
            return null;
        }
    }
  learner_created: true
- name: src/account/entites/Event.java
  visible: true
  text: |
    package account.entites;

    import account.util.Action;

    import javax.persistence.*;
    import java.time.LocalDateTime;

    @Entity
    public class Event {
        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        @Column(name = "id", nullable = false)
        private Long id;

        private LocalDateTime date;
        private Action action;
        private String subject;
        private String object;
        private String path;

        public Event() {
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public LocalDateTime getDate() {
            return date;
        }

        public void setDate(LocalDateTime date) {
            this.date = date;
        }

        public Action getAction() {
            return action;
        }

        public void setAction(Action action) {
            this.action = action;
        }

        public String getSubject() {
            return subject;
        }

        public void setSubject(String subject) {
            this.subject = subject;
        }

        public String getObject() {
            return object;
        }

        public void setObject(String object) {
            this.object = object;
        }

        public String getPath() {
            return path;
        }

        public void setPath(String path) {
            this.path = path;
        }
    }
  learner_created: true
- name: src/account/service/SecurityService.java
  visible: true
  text: |
    package account.service;

    import account.entites.Event;
    import account.entites.User;
    import account.repository.EventRepository;
    import account.util.Action;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.authentication.AnonymousAuthenticationToken;
    import org.springframework.security.core.Authentication;
    import org.springframework.security.core.context.SecurityContextHolder;
    import org.springframework.stereotype.Service;

    import javax.servlet.http.HttpServletRequest;
    import java.nio.charset.StandardCharsets;
    import java.time.LocalDateTime;
    import java.util.ArrayList;
    import java.util.Base64;
    import java.util.List;

    @Service
    public class SecurityService {
        @Autowired
        private EventRepository eventRepository;
        @Autowired
        private FailedLoginService failedLoginService;
        @Autowired
        private UserService userService;

        public ResponseEntity<List<Event>> getEvents() {
            List<Event> events = new ArrayList<>();
            eventRepository.findAll().iterator().forEachRemaining(events::add);
            return ResponseEntity.ok().body(events);
        }

        public void createNewUserEvent(User user) {
            Event event = new Event();
            event.setDate(LocalDateTime.now());
            event.setAction(Action.CREATE_USER);
            event.setSubject("Anonymous");
            event.setObject(user.getEmail());
            event.setPath("/api/auth/signup");
            eventRepository.save(event);
        }

        public void createDeleteUserEvent(User user) {
            Event event = new Event();
            event.setDate(LocalDateTime.now());
            event.setAction(Action.DELETE_USER);
            event.setSubject(getCurrentUserName());
            event.setObject(user.getEmail());
            event.setPath("/api/admin/user");
            eventRepository.save(event);
        }

        public void createChangePasswordEvent(User user) {
            Event event = new Event();
            event.setDate(LocalDateTime.now());
            event.setAction(Action.CHANGE_PASSWORD);
            event.setSubject(user.getEmail());
            event.setObject(user.getEmail());
            event.setPath("/api/auth/changepass");
            eventRepository.save(event);
        }

        public void createGrantRoleEvent(User user, String roleFromReq) {
            Event event = new Event();
            event.setDate(LocalDateTime.now());
            event.setAction(Action.GRANT_ROLE);
            event.setSubject(getCurrentUserName());
            event.setObject(String.format("Grant role %s to %s", roleFromReq, user.getEmail()));
            event.setPath("/api/admin/user/role");
            eventRepository.save(event);
        }

        public void createRemoveRoleEvent(User user, String roleFromReq) {
            Event event = new Event();
            event.setDate(LocalDateTime.now());
            event.setAction(Action.REMOVE_ROLE);
            event.setSubject(getCurrentUserName());
            event.setObject(String.format("Remove role %s from %s", roleFromReq, user.getEmail()));
            event.setPath("/api/admin/user/role");
            eventRepository.save(event);
        }

        public void createUnlockUserEvent(User user) {
            Event event = new Event();
            event.setDate(LocalDateTime.now());
            event.setAction(Action.UNLOCK_USER);
            event.setSubject(getCurrentUserName());
            event.setObject("Unlock user " + user.getEmail());
            event.setPath("/api/admin/user/access");
            eventRepository.save(event);
        }

        public void createManualLockUserEvent(User user) {
            Event event = new Event();
            event.setDate(LocalDateTime.now());
            event.setAction(Action.LOCK_USER);
            event.setSubject(getCurrentUserName());
            event.setObject("Lock user " + user.getEmail());
            event.setPath("/api/admin/user/access");
            eventRepository.save(event);
        }

        public void createLockUserEvent(HttpServletRequest request) {
            Event event = new Event();
            event.setDate(LocalDateTime.now());
            event.setAction(Action.LOCK_USER);
            event.setSubject(getFailedLogin(request));
            event.setObject("Lock user " + getFailedLogin(request));
            event.setPath(request.getRequestURI()); // the endpoint where the event occurred
            eventRepository.save(event);
        }

        public void createBruteForceEvent(HttpServletRequest request) {
            Event event = new Event();
            event.setDate(LocalDateTime.now());
            event.setAction(Action.BRUTE_FORCE);
            event.setSubject(getFailedLogin(request));
            event.setObject(request.getRequestURI()); // the endpoint where the event occurred
            event.setPath(request.getRequestURI()); // the endpoint where the event occurred
            eventRepository.save(event);
        }

        public void createAccessDeniedEvent(HttpServletRequest request) {
            Event event = new Event();
            event.setDate(LocalDateTime.now());
            event.setAction(Action.ACCESS_DENIED);
            event.setSubject(getCurrentUserName());
            event.setObject(request.getRequestURI()); // the endpoint where the event occurred
            event.setPath(request.getRequestURI()); // the endpoint where the event occurred
            eventRepository.save(event);
        }

        public void createLoginFailedEvent(HttpServletRequest request) {
            Event event = new Event();
            event.setDate(LocalDateTime.now());
            event.setAction(Action.LOGIN_FAILED);
            event.setSubject(getFailedLogin(request));
            event.setObject(request.getRequestURI()); // the endpoint where the event occurred
            event.setPath(request.getRequestURI()); // the endpoint where the event occurred
            eventRepository.save(event);
        }

        private String getFailedLogin(HttpServletRequest request) {
            String failedLogin = request.getHeader("Authorization").replaceAll("Basic ", "");
            String decodedLogin = new String(Base64.getDecoder().decode(failedLogin.getBytes(StandardCharsets.UTF_8)));
            decodedLogin = decodedLogin.substring(0, decodedLogin.indexOf(":"));
            return decodedLogin;
        }

        private String getCurrentUserName() {
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            String currentUserName = "";
            if (!(authentication instanceof AnonymousAuthenticationToken)) {
                User user = (User) authentication.getPrincipal();
                currentUserName = user.getEmail();
            }
            return currentUserName;
        }

        public void createFailedBrutLockEvent(HttpServletRequest request) {
            int count = failedLoginService.getCountFailedLogin(getFailedLogin(request));
            if (count == 5) {
                createLoginFailedEvent(request);
                createBruteForceEvent(request);
                createLockUserEvent(request);
                userService.automaticLockUser(getFailedLogin(request));
            } else if(count < 5) {
                createLoginFailedEvent(request);
            }
            failedLoginService.failedLoginUpdate(getFailedLogin(request));
        }

    }
  learner_created: true
- name: src/account/service/UserService.java
  visible: true
  text: |
    package account.service;

    import account.dto.ChangeUserPasswordResponse;
    import account.dto.DeleteUserResponse;
    import account.dto.UserStatusChangeRequest;
    import account.dto.UserStatusChangeResponse;
    import account.repository.UserRepository;
    import account.util.Operation;
    import account.util.Role;
    import account.entites.User;
    import account.exceptionhandler.exception.BreachedPasswordException;
    import account.exceptionhandler.exception.InvalidLengthPasswordException;
    import account.exceptionhandler.exception.RepetitivePasswordException;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.security.core.userdetails.UserDetailsService;
    import org.springframework.security.core.userdetails.UsernameNotFoundException;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.stereotype.Service;
    import org.springframework.web.server.ResponseStatusException;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.Optional;

    @Service
    public class UserService implements UserDetailsService {
        @Autowired
        private final UserRepository userRepository;
        @Autowired
        private SecurityService securityService;
        @Autowired
        private List<String> breachedPasswords;
        @Autowired
        private PasswordEncoder passwordEncoder;
        @Autowired
        private FailedLoginService failedLoginService;

        public UserService(UserRepository userRepository) {
            this.userRepository = userRepository;
        }

        public User findByEmail(String email) {
            return userRepository.findUserByEmailIgnoreCase(email.toLowerCase())
                    .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found!"));
        }

        public User registerNewUser(User user) {
            user.setEmail(user.getEmail().toLowerCase());
            checkValidPassword(user.getPassword());
            if (userRepository.count() == 0) {
                user.grantAuthority(Role.ROLE_ADMINISTRATOR);
                user.setPassword(passwordEncoder.encode(user.getPassword()));
                userRepository.save(user);
                securityService.createNewUserEvent(user);
            } else if (userRepository.findUserByEmailIgnoreCase(user.getEmail()).isEmpty()) {
                user.grantAuthority(Role.ROLE_USER);
                user.setPassword(passwordEncoder.encode(user.getPassword()));
                userRepository.save(user);
                securityService.createNewUserEvent(user);
            } else throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "User exist!");
            return user;
        }

        public ResponseEntity<ChangeUserPasswordResponse> changePassword(String newPassword, User authUser) {
            checkValidPassword(newPassword);
            checkDifferencePasswords(newPassword, authUser.getPassword());
            User tmpUser = userRepository.findUserByEmailIgnoreCase(authUser.getEmail()).get();
            tmpUser.setPassword(passwordEncoder.encode(newPassword));
            userRepository.save(tmpUser);
            securityService.createChangePasswordEvent(tmpUser);
            return ResponseEntity.ok().body(new ChangeUserPasswordResponse(authUser.getEmail(), "The password has been updated successfully"));
        }

        public ResponseEntity<List<User>> getUsersInfo() {
            List<User> users = new ArrayList<>();
            userRepository.findAll().iterator().forEachRemaining(users::add);
            return ResponseEntity.ok().body(users);
        }

        public ResponseEntity<DeleteUserResponse> deleteUser(String email) {
            User user = userRepository.findUserByEmailIgnoreCase(email)
                    .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found!"));
            if (user.getRoles().contains(Role.ROLE_ADMINISTRATOR))
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Can't remove ADMINISTRATOR role!");
            userRepository.delete(user);
            securityService.createDeleteUserEvent(user);
            return ResponseEntity.ok().body(new DeleteUserResponse(user.getEmail(), "Deleted successfully!"));
        }

        public ResponseEntity<UserStatusChangeResponse> changeUserStatus(UserStatusChangeRequest request) {
            User user = userRepository.findUserByEmailIgnoreCase(request.getUser())
                    .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found!"));

            if (user.getRoles().contains(Role.ROLE_ADMINISTRATOR))
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Can't lock the ADMINISTRATOR!");
            if (request.getOperation().equals(Operation.LOCK.name())) {
                user.setAccountNonLocked(false);
                userRepository.save(user);
                securityService.createManualLockUserEvent(user);
                return ResponseEntity.ok().body(new UserStatusChangeResponse("User " + request.getUser().toLowerCase() + " locked!"));
            } else if (request.getOperation().equals(Operation.UNLOCK.name())) {
                user.setAccountNonLocked(true);
                userRepository.save(user);
                failedLoginService.resetCounterFailedLogin(user.getEmail());
                securityService.createUnlockUserEvent(user);
                return ResponseEntity.ok().body(new UserStatusChangeResponse("User " + request.getUser().toLowerCase() + " unlocked!"));
            } else {
                throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Operation not found!");
            }
        }

        public void automaticLockUser(String email) {
            User user = userRepository.findUserByEmailIgnoreCase(email)
                    .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found!"));
            if (user.getRoles().contains(Role.ROLE_ADMINISTRATOR))
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Can't lock the ADMINISTRATOR!");
            user.setAccountNonLocked(false);
            userRepository.save(user);
        }

        @Override
        public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
            Optional<User> user = userRepository.findUserByEmailIgnoreCase(email);

            if (user.isPresent()) {
                return user.get();
            } else {
                throw new UsernameNotFoundException(String.format("Username[%s] not found", email));
            }
        }

        private void checkValidPassword(String password) {
            if (password == null || password.length() < 12) {
                throw new InvalidLengthPasswordException();
            }
            if (breachedPasswords.contains(password)) {
                throw new BreachedPasswordException();
            }
        }

        private void checkDifferencePasswords(String newPassword, String oldPassword) {
            if (passwordEncoder.matches(newPassword, oldPassword)) {
                throw new RepetitivePasswordException();
            }
        }
    }
  learner_created: true
- name: src/account/dto/UserStatusChangeResponse.java
  visible: true
  text: |
    package account.dto;

    public class UserStatusChangeResponse {
        private String status;

        public String getStatus() {
            return status;
        }

        public void setStatus(String status) {
            this.status = status;
        }

        public UserStatusChangeResponse() {
        }

        public UserStatusChangeResponse(String status) {
            this.status =  status;
        }
    }
  learner_created: true
- name: src/account/exceptionhandler/RestAccessDeniedHandler.java
  visible: true
  text: |
    package account.exceptionhandler;

    import account.service.SecurityService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.access.AccessDeniedException;
    import org.springframework.security.web.access.AccessDeniedHandler;
    import org.springframework.stereotype.Component;

    import javax.servlet.ServletException;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;

    @Component
    public class RestAccessDeniedHandler implements AccessDeniedHandler {
        @Autowired
        private SecurityService securityService;

        @Override
        public void handle(HttpServletRequest request,
                           HttpServletResponse response,
                           AccessDeniedException accessDeniedException) throws IOException, ServletException {

            securityService.createAccessDeniedEvent(request);
            response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied!");
        }
    }
  learner_created: true
- name: src/account/exceptionhandler/exception/PaymentNotFoundException.java
  visible: true
  text: |
    package account.exceptionhandler.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST,reason = "Payment by this period not found")
    public class PaymentNotFoundException extends RuntimeException{
    }
  learner_created: true
- name: src/account/exceptionhandler/exception/SalaryException.java
  visible: true
  text: |
    package account.exceptionhandler.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST,reason = "Salary must be non negative!")
    public class SalaryException extends RuntimeException {
    }
  learner_created: true
- name: src/account/exceptionhandler/exception/DuplicatePaymentException.java
  visible: true
  text: |
    package account.exceptionhandler.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "Payment already exists!")
    public class DuplicatePaymentException extends RuntimeException{
    }
  learner_created: true
- name: src/account/exceptionhandler/exception/EmployeeNotFoundException.java
  visible: true
  text: |
    package account.exceptionhandler.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "Employee not found!")
    public class EmployeeNotFoundException extends RuntimeException{
    }
  learner_created: true
- name: src/account/exceptionhandler/exception/RepetitivePasswordException.java
  visible: true
  text: |-
    package account.exceptionhandler.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "The passwords must be different!")
    public class RepetitivePasswordException extends RuntimeException {}
  learner_created: true
- name: src/account/exceptionhandler/AuthenticationSuccessListener.java
  visible: true
  text: |-
    package account.exceptionhandler;

    import account.entites.User;
    import account.service.FailedLoginService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.ApplicationListener;
    import org.springframework.security.authentication.event.AuthenticationSuccessEvent;
    import org.springframework.stereotype.Component;

    @Component
    public class AuthenticationSuccessListener implements ApplicationListener<AuthenticationSuccessEvent> {

        @Autowired
        private FailedLoginService failedLoginService;

        @Override
        public void onApplicationEvent(AuthenticationSuccessEvent event) {
            User user = (User) event.getAuthentication().getPrincipal();
            failedLoginService.resetCounterFailedLogin(user.getEmail());
        }
    }
  learner_created: true
- name: src/account/exceptionhandler/exception/InvalidLengthPasswordException.java
  visible: true
  text: |
    package account.exceptionhandler.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "Password length must be 12 chars minimum!")
    public class InvalidLengthPasswordException extends RuntimeException{
    }
  learner_created: true
- name: src/account/exceptionhandler/exception/WrongPeriodException.java
  visible: true
  text: |
    package account.exceptionhandler.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "Wrong period!")
    public class WrongPeriodException extends RuntimeException {
    }
  learner_created: true
- name: src/account/exceptionhandler/RestAuthenticationEntryPoint.java
  visible: true
  text: |-
    package account.exceptionhandler;

    import account.service.SecurityService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.core.AuthenticationException;
    import org.springframework.security.web.AuthenticationEntryPoint;
    import org.springframework.stereotype.Component;

    import javax.servlet.ServletException;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import java.io.IOException;

    @Component
    public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint {
        @Autowired
        private SecurityService securityService;

        @Override
        public void commence(HttpServletRequest request,
                             HttpServletResponse response,
                             AuthenticationException authException) throws IOException, ServletException {

            if (request.getHeader("Authorization") != null)
                securityService.createFailedBrutLockEvent(request);
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, authException.getMessage());
        }
    }
  learner_created: true
- name: src/account/exceptionhandler/exception/BreachedPasswordException.java
  visible: true
  text: |-
    package account.exceptionhandler.exception;

    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.ResponseStatus;

    @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "The password is in the hacker's database!")
    public class BreachedPasswordException extends RuntimeException {}
  learner_created: true
- name: src/resources/keystore/service.p12
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/16607#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Sun, 05 Jun 2022 14:38:46 UTC
record: -1
